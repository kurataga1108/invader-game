<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; background: #000; overflow: hidden; touch-action: none; font-family: sans-serif; }
    canvas { display: block; background: #000; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="g"></canvas>
  <script>
    const cvs = document.getElementById("g");
    const ctx = cvs.getContext("2d");
    cvs.width = window.innerWidth;
    cvs.height = window.innerHeight;

    let px, bullets, eBullets, enemies, particles, enemyDir, score, lives, gameState, boss, difficulty;
    let lastTouchX = 0;
    const btn = { x: 0, y: 0, w: 200, h: 50 };
    const diffBtns = [
      { id: "Easy", x: 0, y: 0, w: 90, h: 45 },
      { id: "Normal", x: 0, y: 0, w: 90, h: 45 },
      { id: "Hard", x: 0, y: 0, w: 90, h: 45 }
    ];

    function init(diff = "Normal") {
      difficulty = diff;
      px = cvs.width / 2;
      bullets = []; eBullets = []; enemies = []; particles = [];
      enemyDir = 1; score = 0; lives = 3; gameState = "play"; boss = null;
      
      // ハードでも数はNormalと同じ(6列x4行)
      let rows = 4;
      let cols = 6;
      let hpMult = diff === "Hard" ? 2 : 1;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          enemies.push({ 
            x: c * (cvs.width/(cols+1)) + 30, 
            y: r * 40 + 80, 
            alive: true, 
            hp: hpMult 
          });
        }
      }
    }

    function createExplosion(x, y, color, count = 6) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x, y: y,
          vx: (Math.random() - 0.5) * 5,
          vy: (Math.random() - 0.5) * 5,
          life: 20, // 寿命を少し短くして軽量化
          color: color
        });
      }
    }

    window.addEventListener("touchstart", (e) => {
      const tx = e.touches[0].clientX;
      const ty = e.touches[0].clientY;

      if (gameState === "menu") {
        for (const b of diffBtns) {
          if (tx > b.x && tx < b.x + b.w && ty > b.y && ty < b.y + b.h) {
            difficulty = b.id;
            return;
          }
        }
        if (tx > btn.x && tx < btn.x + btn.w && ty > btn.y && ty < btn.y + btn.h) init(difficulty);
      } else if (gameState === "play") {
        lastTouchX = tx;
        bullets.push({ x: px, y: cvs.height - 80 });
      } else {
        if (tx > btn.x && tx < btn.x + btn.w && ty > btn.y && ty < btn.y + btn.h) gameState = "menu";
      }
      e.preventDefault();
    }, { passive: false });

    window.addEventListener("touchmove", (e) => {
      if (gameState === "play") {
        const touchX = e.touches[0].clientX;
        px += (touchX - lastTouchX);
        lastTouchX = touchX;
        px = Math.max(20, Math.min(cvs.width - 20, px));
      }
      e.preventDefault();
    }, { passive: false });

    function loop() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, cvs.width, cvs.height);

      if (gameState === "menu") drawMenu();
      else if (gameState === "play") updatePlay();
      else drawResult();

      requestAnimationFrame(loop);
    }

    function updatePlay() {
      ctx.fillStyle = "#0f0";
      ctx.fillRect(px - 20, cvs.height - 80, 40, 20);

      particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.life--;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 2, 2);
        if (p.life <= 0) particles.splice(i, 1);
      });

      ctx.fillStyle = "white";
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i]; b.y -= 9;
        ctx.fillRect(b.x - 2, b.y, 4, 10);
        
        enemies.forEach(e => {
          if (e.alive && b.x > e.x && b.x < e.x + 30 && b.y > e.y && b.y < e.y + 25) {
            e.hp--; bullets.splice(i, 1);
            if(e.hp <= 0) {
              e.alive = false; score += 10;
              createExplosion(e.x + 15, e.y + 12, "red");
            }
          }
        });
        if (boss && boss.hp > 0 && b.x > boss.x && b.x < boss.x + 80 && b.y > boss.y && b.y < boss.y + 40) {
          boss.hp--; bullets.splice(i, 1);
          createExplosion(b.x, b.y, "orange", 3);
          if (boss.hp <= 0) { 
            createExplosion(boss.x + 40, boss.y + 20, "purple", 15);
            score += lives * 500; gameState = "clear"; 
          }
        }
        else if (b.y < 0) bullets.splice(i, 1);
      }

      ctx.fillStyle = "yellow";
      for (let i = eBullets.length - 1; i >= 0; i--) {
        let eb = eBullets[i]; eb.y += 4.5; if (eb.vx) eb.x += eb.vx;
        ctx.beginPath(); ctx.arc(eb.x, eb.y, eb.size || 3, 0, Math.PI*2); ctx.fill();
        if (eb.x > px - 20 && eb.x < px + 20 && eb.y > cvs.height - 80 && eb.y < cvs.height - 60) {
          eBullets.splice(i, 1); lives--;
          createExplosion(px, cvs.height - 70, "#0f0", 10);
          if (lives <= 0) gameState = "over";
        }
        else if (eb.y > cvs.height) eBullets.splice(i, 1);
      }

      let moveDown = false, aliveCount = 0;
      let shootRate = difficulty === "Easy" ? 0.002 : (difficulty === "Hard" ? 0.007 : 0.005);
      enemies.forEach(e => {
        if (!e.alive) return;
        aliveCount++; e.x += 1.5 * enemyDir; // スピードはNormalと同じ
        if (e.x > cvs.width - 40 || e.x < 10) moveDown = true;
        ctx.fillStyle = e.hp > 1 ? "#f0f" : "red";
        ctx.fillRect(e.x, e.y, 30, 25);
        if (Math.random() < shootRate) eBullets.push({ x: e.x + 15, y: e.y + 25 });
      });
      if (moveDown) { enemyDir *= -1; enemies.forEach(e => e.y += 15); }

      if (aliveCount === 0 && !boss) {
        let bhp = difficulty === "Easy" ? 10 : (difficulty === "Hard" ? 40 : 20);
        boss = { x: cvs.width/2-40, y: 50, hp: bhp, maxHp: bhp, dir: 1 };
      }
      if (boss) {
        boss.x += 2 * boss.dir; boss.y += 0.1;
        if (boss.x > cvs.width - 80 || boss.x < 0) boss.dir *= -1;
        ctx.fillStyle = boss.hp < boss.maxHp/4 ? "orange" : "purple";
        ctx.fillRect(boss.x, boss.y, 80, 40);
        if (Math.random() < (difficulty === "Hard" ? 0.05 : 0.03)) {
          [-2, 0, 2].forEach(vx => eBullets.push({ x: boss.x + 40, y: boss.y + 40, vx: vx, vy: 5, size: 6 }));
        }
      }
      
      ctx.fillStyle = "white"; ctx.font = "18px Arial"; ctx.textAlign = "left";
      ctx.fillText("SCORE: " + score, 20, 30);
      ctx.fillText("LIVES: " + "❤".repeat(lives), cvs.width - 120, 30);
    }

    function drawMenu() {
      ctx.fillStyle = "white"; ctx.textAlign = "center";
      ctx.font = "bold 32px Arial"; ctx.fillText("INVADER GAME", cvs.width/2, 140);
      ctx.font = "18px Arial"; ctx.fillText("難易度を選択:", cvs.width/2, 230);
      
      diffBtns.forEach((b, i) => {
        b.x = cvs.width/2 - 145 + i * 100; b.y = 260;
        ctx.fillStyle = difficulty === b.id ? "#0f0" : "#333";
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.fillStyle = "white"; ctx.font = "bold 15px Arial"; ctx.fillText(b.id, b.x + b.w/2, b.y + 28);
      });
      drawButton("スタート", cvs.height - 180);
    }

    function drawResult() {
      ctx.fillStyle = gameState === "over" ? "red" : "yellow";
      ctx.textAlign = "center"; ctx.font = "36px Arial";
      ctx.fillText(gameState === "over" ? "GAME OVER" : "MISSION CLEAR!", cvs.width/2, cvs.height/2 - 60);
      ctx.fillStyle = "white"; ctx.font = "20px Arial";
      ctx.fillText("最終スコア: " + score, cvs.width/2, cvs.height/2 - 10);
      drawButton("メニューに戻る", cvs.height/2 + 60);
    }

    function drawButton(text, y) {
      btn.x = cvs.width/2 - 100; btn.y = y;
      ctx.fillStyle = "#444"; ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
      ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
      ctx.fillStyle = "white"; ctx.font = "bold 18px Arial"; ctx.textAlign = "center";
      ctx.fillText(text, cvs.width/2, btn.y + 32);
    }

    gameState = "menu";
    difficulty = "Normal";
    loop();
  </script>
</body>
</html>
