<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; background: #000; overflow: hidden; touch-action: none; font-family: sans-serif; }
    canvas { display: block; background: #000; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="g"></canvas>
  <script>
    const cvs = document.getElementById("g");
    const ctx = cvs.getContext("2d");
    cvs.width = window.innerWidth;
    cvs.height = window.innerHeight;

    let px, bullets, eBullets, enemies, enemyDir, score, lives, gameState, boss;
    let lastTouchX = 0;

    // ボタンの範囲を定義
    const btn = { x: 0, y: 0, w: 200, h: 60 };

    function init() {
      px = cvs.width / 2;
      bullets = [];
      eBullets = [];
      enemies = [];
      enemyDir = 1;
      score = 0;
      lives = 3;
      gameState = "play";
      boss = null;
      
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 6; c++) {
          enemies.push({ x: c * 50 + 40, y: r * 40 + 70, alive: true });
        }
      }
    }

    window.addEventListener("touchstart", (e) => {
      const tx = e.touches[0].clientX;
      const ty = e.touches[0].clientY;

      if (gameState === "play") {
        lastTouchX = tx;
        bullets.push({ x: px, y: cvs.height - 80 });
      } else {
        // ボタンが押されたか判定
        if (tx > btn.x && tx < btn.x + btn.w && ty > btn.y && ty < btn.y + btn.h) {
          init();
        }
      }
      e.preventDefault();
    }, { passive: false });

    window.addEventListener("touchmove", (e) => {
      if (gameState === "play") {
        const touchX = e.touches[0].clientX;
        const diffX = touchX - lastTouchX;
        px += diffX;
        lastTouchX = touchX;
        if (px < 20) px = 20;
        if (px > cvs.width - 20) px = cvs.width - 20;
      }
      e.preventDefault();
    }, { passive: false });

    function loop() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, cvs.width, cvs.height);

      if (gameState === "play") {
        ctx.fillStyle = "#0f0";
        ctx.fillRect(px - 20, cvs.height - 80, 40, 20);

        ctx.fillStyle = "white";
        bullets.forEach((b, bi) => {
          b.y -= 8;
          ctx.fillRect(b.x - 2, b.y, 4, 10);
          enemies.forEach((e) => {
            if (e.alive && b.x > e.x && b.x < e.x + 30 && b.y > e.y && b.y < e.y + 25) {
              e.alive = false;
              bullets.splice(bi, 1);
              score += 10;
            }
          });
          if (boss && boss.hp > 0 && b.x > boss.x && b.x < boss.x + 80 && b.y > boss.y && b.y < boss.y + 40) {
            boss.hp--;
            bullets.splice(bi, 1);
            if (boss.hp <= 0) {
              score += lives * 500;
              gameState = "clear";
            }
          }
          if (b.y < 0) bullets.splice(bi, 1);
        });

        ctx.fillStyle = "yellow";
        eBullets.forEach((eb, ebi) => {
          eb.y += eb.vy || 4;
          if (eb.vx) eb.x += eb.vx;
          ctx.beginPath();
          ctx.arc(eb.x, eb.y, eb.size || 3, 0, Math.PI*2);
          ctx.fill();
          if (eb.x > px - 20 && eb.x < px + 20 && eb.y > cvs.height - 80 && eb.y < cvs.height - 60) {
            eBullets.splice(ebi, 1);
            lives--;
            if (lives <= 0) gameState = "over";
          }
          if (eb.y > cvs.height) eBullets.splice(ebi, 1);
        });

        let moveDown = false;
        let aliveCount = 0;
        enemies.forEach(e => {
          if (!e.alive) return;
          aliveCount++;
          e.x += 1.5 * enemyDir;
          if (e.x > cvs.width - 40 || e.x < 10) moveDown = true;
          ctx.fillStyle = "red";
          ctx.fillRect(e.x, e.y, 30, 25);
          if (Math.random() < 0.005) eBullets.push({ x: e.x + 15, y: e.y + 25 });
        });

        if (moveDown) {
          enemyDir *= -1;
          enemies.forEach(e => { e.y += 15; if(e.y > cvs.height - 100) gameState = "over"; });
        }

        if (aliveCount === 0 && !boss) {
          boss = { x: cvs.width / 2 - 40, y: 50, hp: 20, dir: 1 };
        }

        if (boss) {
          boss.x += 2 * boss.dir;
          boss.y += 0.1;
          if (boss.x > cvs.width - 80 || boss.x < 0) boss.dir *= -1;
          ctx.fillStyle = boss.hp > 5 ? "purple" : "orange";
          ctx.fillRect(boss.x, boss.y, 80, 40);
          if (Math.random() < 0.03) {
            [-2, 0, 2].forEach(vx => {
              eBullets.push({ x: boss.x + 40, y: boss.y + 40, vx: vx, vy: 5, size: 6 });
            });
          }
          if (boss.y > cvs.height - 120) gameState = "over";
        }
      }

      ctx.fillStyle = "white";
      ctx.font = "18px Arial";
      ctx.textAlign = "left";
      ctx.fillText("SCORE: " + score, 20, 30);
      ctx.fillText("LIVES: " + "❤".repeat(lives), cvs.width - 120, 30);

      if (gameState === "over") {
        showScreen("GAME OVER", "red");
      } else if (gameState === "clear") {
        showScreen("MISSION CLEAR!", "yellow", "Bonus Score: " + (lives * 500));
      }
      requestAnimationFrame(loop);
    }

    function showScreen(text, color, sub) {
      ctx.fillStyle = color;
      ctx.font = "40px Arial";
      ctx.textAlign = "center";
      ctx.fillText(text, cvs.width / 2, cvs.height / 2 - 40);
      
      ctx.font = "20px Arial";
      ctx.fillStyle = "white";
      if(sub) ctx.fillText(sub, cvs.width / 2, cvs.height / 2);

      // 再挑戦ボタンの描画
      btn.x = cvs.width / 2 - 100;
      btn.y = cvs.height / 2 + 40;
      ctx.fillStyle = "#333";
      ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
      
      ctx.fillStyle = "white";
      ctx.font = "bold 20px Arial";
      ctx.fillText("再挑戦する", cvs.width / 2, btn.y + 38);
    }

    init();
    loop();
  </script>
</body>
</html>
